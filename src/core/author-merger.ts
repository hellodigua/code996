/**
 * 作者合并工具
 * 用于检测和合并同一作者的不同邮箱/名称变体
 */

export interface AuthorIdentity {
  name: string
  email: string
  commitCount?: number
}

export interface AuthorGroup {
  primaryName: string
  identities: AuthorIdentity[]
  totalCommits: number
  needsMerge: boolean // 是否需要合并（存在多个邮箱）
}

export interface MergeResult {
  groups: AuthorGroup[]
  mailmapContent: string
  stats: {
    totalAuthors: number
    uniqueNames: number
    needsMerge: number
  }
}

export class AuthorMerger {
  /**
   * 获取作者合并映射表（email -> primary identity）
   * 用于在统计时将同名不同邮箱的作者合并
   */
  public getMergeMap(authors: AuthorIdentity[]): Map<string, { name: string; email: string }> {
    const result = this.analyzeAuthors(authors)
    const mergeMap = new Map<string, { name: string; email: string }>()

    for (const group of result.groups) {
      if (!group.needsMerge) {
        continue
      }

      // 主身份（提交数最多的）
      const primaryIdentity = group.identities[0]

      // 将所有身份映射到主身份
      for (const identity of group.identities) {
        mergeMap.set(identity.email.toLowerCase(), {
          name: group.primaryName,
          email: primaryIdentity.email,
        })
      }
    }

    return mergeMap
  }

  /**
   * 分析作者列表，按名称分组
   */
  public analyzeAuthors(authors: AuthorIdentity[]): MergeResult {
    // 1. 统计每个身份的提交数（如果没有则默认为1）
    const identitiesWithCount = authors.map((a) => ({
      ...a,
      commitCount: a.commitCount ?? 1,
    }))

    // 2. 按名称分组（不区分大小写）
    const nameGroups = new Map<string, AuthorIdentity[]>()

    for (const identity of identitiesWithCount) {
      const normalizedName = identity.name.toLowerCase().trim()
      if (!nameGroups.has(normalizedName)) {
        nameGroups.set(normalizedName, [])
      }
      nameGroups.get(normalizedName)!.push(identity)
    }

    // 3. 构建分组结果
    const groups: AuthorGroup[] = []

    nameGroups.forEach((identities, normalizedName) => {
      // 去重邮箱（同一名称下可能有重复邮箱）
      const uniqueIdentities = this.deduplicateIdentities(identities)

      // 选择出现次数最多的名称作为主名称（保留原始大小写）
      const primaryName = this.selectPrimaryName(uniqueIdentities)

      const totalCommits = uniqueIdentities.reduce((sum, id) => sum + (id.commitCount || 0), 0)

      groups.push({
        primaryName,
        identities: uniqueIdentities.sort((a, b) => (b.commitCount || 0) - (a.commitCount || 0)),
        totalCommits,
        needsMerge: uniqueIdentities.length > 1,
      })
    })

    // 4. 生成 .mailmap 内容
    const mailmapContent = this.generateMailmap(groups)

    // 5. 统计信息
    const stats = {
      totalAuthors: authors.length,
      uniqueNames: groups.length,
      needsMerge: groups.filter((g) => g.needsMerge).length,
    }

    return {
      groups: groups.sort((a, b) => b.totalCommits - a.totalCommits),
      mailmapContent,
      stats,
    }
  }

  /**
   * 去重身份（相同邮箱只保留一个，合并提交数）
   */
  private deduplicateIdentities(identities: AuthorIdentity[]): AuthorIdentity[] {
    const emailMap = new Map<string, AuthorIdentity>()

    for (const identity of identities) {
      const normalizedEmail = identity.email.toLowerCase()
      const existing = emailMap.get(normalizedEmail)

      if (existing) {
        // 合并提交数，保留更常用的名称大小写
        existing.commitCount = (existing.commitCount || 0) + (identity.commitCount || 0)
      } else {
        emailMap.set(normalizedEmail, { ...identity })
      }
    }

    return Array.from(emailMap.values())
  }

  /**
   * 选择主名称（出现次数最多的原始大小写形式）
   */
  private selectPrimaryName(identities: AuthorIdentity[]): string {
    // 按提交数排序，取第一个的名称
    const sorted = [...identities].sort((a, b) => (b.commitCount || 0) - (a.commitCount || 0))
    return sorted[0].name
  }

  /**
   * 生成 .mailmap 文件内容
   * 格式: Proper Name <proper@email.com> <commit@email.com>
   */
  private generateMailmap(groups: AuthorGroup[]): string {
    const lines: string[] = [
      '# Git mailmap file',
      '# Auto-generated by code996',
      '# Format: Proper Name <proper@email> <commit@email>',
      '',
    ]

    for (const group of groups) {
      if (!group.needsMerge) {
        continue
      }

      // 选择提交数最多的邮箱作为主邮箱
      const primaryIdentity = group.identities[0]
      const properEmail = primaryIdentity.email
      const properName = group.primaryName

      // 其他邮箱都映射到主邮箱
      for (let i = 1; i < group.identities.length; i++) {
        const altIdentity = group.identities[i]
        lines.push(`${properName} <${properEmail}> <${altIdentity.email}>`)
      }

      lines.push('') // 空行分隔不同作者组
    }

    return lines.join('\n')
  }

  /**
   * 相似度检测：判断两个名称是否可能属于同一人
   * 目前只做基础判断，后续可以加入更复杂的算法
   */
  public areSimilarNames(name1: string, name2: string): boolean {
    const n1 = name1.toLowerCase().trim()
    const n2 = name2.toLowerCase().trim()

    // 完全相同
    if (n1 === n2) return true

    // 一个是另一个的子串（处理昵称/简称场景）
    if (n1.includes(n2) || n2.includes(n1)) return true

    // TODO: 可以加入编辑距离、拼音相似度等算法

    return false
  }
}
